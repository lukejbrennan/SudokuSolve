User Perspective:
The user simply runs the program and inputs an unsolved, 9x9, integer sudoku puzzle. The program will then output the finished puzzle or try to do so (and run continuously while outputting nothing).

Program Internals:
The program is an extension from last week’s lab with the addition of 4 major functions and a 3D vector called possibles. The 3D vector stores all of the possibles values that could be placed in a particular cell on the board. For example, the third dimension of possibles for the value 1 (row), 1 (column) could hold the following values: 0 2 3 4 0 0 0 0 9. Zeros indicate that no number can be placed; the 2, 3, 4, 9 are all values that can be placed in the board. The four new functions are updateBoard, simpleSolve, singleton, and synSolve. simpleSolve and singleton are both two separate algorithms to solving a sudoku that both use updateBoard. updateBoard simply updates the third dimension of possibles after a value has been added to the board. If the number 2 was added to the board, for example, updateBoard would go through the column, row, and minigrid to which the number 2 was added and take out any 2’s in possibles for the cells in the same row, column, or minigrid. This ensures that only one 2 is written into the board for every row, column, and minigrid. updateBoard also deletes all possibles from the row and column to which the number was added because there no longer any possibles (there is a value on the board that is certain!) The simpleSolve function works by iterating through the board and checking if there is any cell that has only one, non-zero number that could be placed into the board. If this is the case, then that number is placed and the board is updated. singleton is a function that looks through all of the rows. It creates a temporary vector that holds all the possible values for one cell at a time. Then is goes through all of the columns that also have possible values (skipping the columns that already have a non-zero number in the board). The program reads through all the possible values in the next column, and if any of the possible values in the next column are in the temporary vector, then the value is the temporary vector is deleted. After the temporary vector has been fully altered in this way, the program adds the value in the temporary vector only if there is one number to add. Lastly, synSolve works by using simpleSolve and singleton together. synSolve runs until the game has been won. It calls simpleSolve until simpleSolve stops making changes to the board. If this occurs then the program switches to using the singleton algorithm. 

Verification: To verify the program, I inputted both the easy and the medium level sudoku puzzles. The program was able to solve and output a finished puzzle for each of these.

 More stuff about the program:
I was very satisfied with my usage of 3D arrays and the simpleSolve and synSolve function. I liked how synSolve was able to combine and use both simpleSolve and singleton appropriately. I noticed halfway through the lab that most of my classmates had a 3D vector that had the value on the puzzle board on the foundational level of what was my possibles vector. I did not do this, but I thought my way of doing it worked fine and made sense (so I kept it). I was a little frustrated with my singleton function. I used a lot of for loops, and I am wondering if there is a way to run this algorithm that requires less. For instance, I had to iterate through the possible numbers twice (in nested for loops). I didn’t think there was a way to combine them into one for loop, but I also didn’t really think my way of doing it was efficient. That being said, I was overall satisfied with my functions and program: they worked! If i could improve the program though, I would look at the efficiency of singleton and I would make singleton check both columns and minigrids instead of just each row. 
